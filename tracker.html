<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mass Effect Exploration Tracker — Single File</title>

  <!-- Tailwind Play CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Tailwind theme customization: neon-cyan, deep background
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            mebg: '#071018',       // deep space background
            mepanel: '#0f1720',    // panel
            accent: '#66fcf1',     // neon cyan
            accent2: '#45b8bf',
            muted: '#9aa6ad'
          }
        }
      }
    }
  </script>

  <!-- React + ReactDOM + Babel (JSX in single file) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

  <style>
    body { background: linear-gradient(180deg,#03060a 0%, #071018 60%); }
    /* small custom scrollbar to fit theme */
    ::-webkit-scrollbar { height: 10px; width: 10px; }
    ::-webkit-scrollbar-thumb { background: rgba(102,252,241,0.12); border-radius: 8px; }
  </style>
</head>
<body class="min-h-screen text-gray-100">

  <div id="root" class="p-6 max-w-6xl mx-auto"></div>

  <script type="text/babel">

  const { useState, useEffect, useMemo } = React;

  // Utility: parse CSV (simple, expects header row)
  function parseCSV(text) {
    const lines = text.trim().split(/\r?\n/);
    if (!lines.length) return [];
    // naive CSV split by commas — supports quoted fields
    function splitLine(line) {
      const result = [];
      let cur = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"' ) {
          if (inQuotes && line[i+1] === '"') { cur += '"'; i++; }
          else inQuotes = !inQuotes;
        } else if (ch === ',' && !inQuotes) {
          result.push(cur); cur = '';
        } else cur += ch;
      }
      result.push(cur);
      return result;
    }

    const headers = splitLine(lines[0]).map(h => h.trim());
    const data = [];
    for (let i = 1; i < lines.length; i++) {
      if (!lines[i].trim()) continue;
      const values = splitLine(lines[i]);
      const row = {};
      headers.forEach((h, idx) => row[h || `col${idx}`] = (values[idx]||'').trim());
      data.push(row);
    }
    return data;
  }

  // ID generator for each item
  function makeId(cluster, system, name) {
    return `${cluster}||${system}||${name}`.replace(/\s+/g,'_').toLowerCase();
  }

  // Sample data (small) — user can import their CSV to replace with full data
  const SAMPLE = [
    { cluster: "Argos Rho Cluster", system: "Hydra System", name: "Canrum (Insignia)", tags: "Insignia" },
    { cluster: "Argos Rho Cluster", system: "Hydra System", name: "Metgos (Land: Heavy, Rare)", tags: "Land,Heavy,Rare" },
    { cluster: "Exodus Cluster", system: "Asgard System", name: "Asteroid X57 (Land)(DLC)", tags: "Land,DLC" },
    { cluster: "Local Cluster", system: "Solar System", name: "Luna (Land)", tags: "Land" },
    { cluster: "Exodus Cluster", system: "Han System", name: "Mavigon (Land: Medallion, Light, Heavy)", tags: "Land,Medallion,Light,Heavy" },
  ];

  // Key used in localStorage
  const STORAGE_KEY = 'me_tracker_v1_state';

  // Convert flat rows to hierarchical clusters -> systems -> items
  function buildHierarchy(rows) {
    const clusters = {};
    rows.forEach(r => {
      const cluster = r.cluster || 'Unknown Cluster';
      const system = r.system || 'Unknown System';
      const name = r.name || r.location || r.item || 'Unnamed';
      const tags = (r.tags || r.type || '').split(',').map(t => t.trim()).filter(Boolean);
      const id = makeId(cluster, system, name);
      if (!clusters[cluster]) clusters[cluster] = {};
      if (!clusters[cluster][system]) clusters[cluster][system] = [];
      clusters[cluster][system].push({ id, name, tags });
    });

    // convert to arrays
    return Object.keys(clusters).sort().map(clusterName => {
      const systems = Object.keys(clusters[clusterName]).sort().map(systemName => ({
        name: systemName,
        items: clusters[clusterName][systemName]
      }));
      return { name: clusterName, systems };
    });
  }

  function saveState(state) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }
  function loadState() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch(e){ return null; }
  }

  // Progress helpers
  function countCompleted(items, checkedMap) {
    let done = 0;
    items.forEach(it => { if (checkedMap[it.id]) done++; });
    return { done, total: items.length, pct: items.length ? Math.round(100 * (done/items.length)) : 0 };
  }

  // Main App
  function App() {
    // hierarchical data structure used to render
    const [rows, setRows] = useState(() => {
      // try loading previously imported rows from saved state first
      const s = loadState();
      if (s && s.rows) return s.rows;
      return SAMPLE;
    });

    const [checkedMap, setCheckedMap] = useState(() => {
      const s = loadState();
      return (s && s.checkedMap) ? s.checkedMap : {};
    });

    const [search, setSearch] = useState('');
    const [collapsedClusters, setCollapsedClusters] = useState({});
    const [collapsedSystems, setCollapsedSystems] = useState({});
    const [filterTags, setFilterTags] = useState(''); // comma-separated tags filter

    // save automatically when rows or checkedMap changes
    useEffect(() => {
      saveState({ rows, checkedMap });
    }, [rows, checkedMap]);

    const hierarchy = useMemo(() => buildHierarchy(rows), [rows]);

    // collect tag suggestions
    const allTags = useMemo(() => {
      const s = new Set();
      rows.forEach(r => {
        ( (r.tags || r.type || '').split(',').map(t=>t.trim()).filter(Boolean) ).forEach(t => s.add(t));
      });
      return Array.from(s).sort();
    }, [rows]);

    // toggle checkbox
    function toggleItem(id) {
      setCheckedMap(prev => {
        const next = { ...prev, [id]: !prev[id] };
        return next;
      });
    }

    // Import CSV text -> rows (cluster, system, name, tags)
    function importCSVText(text) {
      const parsed = parseCSV(text);
      // heuristics: try to map common header names
      const mapped = parsed.map(r => {
        // common header guesses
        const cluster = r.cluster || r.Cluster || r['Cluster Name'] || r['Argos Rho Cluster'] || r['cluster'] || r[Object.keys(r)[0]];
        const system = r.system || r.System || r['System Name'] || r['system'];
        // name could be 'name', 'location', 'planet'
        const name = r.name || r.Name || r.location || r.Location || r.Planet || r.Item || r['name'];
        const tags = r.tags || r.Tags || r.Type || r['Collectible'] || '';
        return { cluster: (cluster||'').trim(), system: (system||'').trim(), name: (name||'').trim(), tags: (tags||'').trim() };
      });
      setRows(mapped);
      // clear checked map — but preserve if ids match names
      // compute ids and re-use any existing checked values where possible:
      const newChecked = {};
      mapped.forEach(r => {
        const id = makeId(r.cluster, r.system, r.name);
        if (checkedMap[id]) newChecked[id] = true;
      });
      setCheckedMap(newChecked);
    }

    // handle CSV file upload
    function handleFile(e) {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (evt) => {
        importCSVText(evt.target.result);
      };
      reader.readAsText(file);
    }

    // reset progress or clear data
    function clearProgress() {
      if (!confirm('Clear all checkboxes?')) return;
      setCheckedMap({});
    }
    function clearAllData() {
      if (!confirm('Clear entire dataset (rows + progress)?')) return;
      setRows([]);
      setCheckedMap({});
      localStorage.removeItem(STORAGE_KEY);
    }

    // filtered view of hierarchy depending on search & filterTags
    const visibleHierarchy = useMemo(() => {
      const q = search.trim().toLowerCase();
      const tagFilters = filterTags.split(',').map(t => t.trim().toLowerCase()).filter(Boolean);
      return hierarchy.map(cluster => {
        const filteredSystems = cluster.systems.map(sys => {
          const filteredItems = sys.items.filter(it => {
            const nameLower = it.name.toLowerCase();
            // search matches cluster/system/name/tags
            const matchesSearch = !q || cluster.name.toLowerCase().includes(q) || sys.name.toLowerCase().includes(q) || nameLower.includes(q) || (it.tags.join(' ').toLowerCase().includes(q));
            // tags filter
            const matchesTags = tagFilters.length === 0 || tagFilters.every(tf => it.tags.map(t=>t.toLowerCase()).includes(tf));
            return matchesSearch && matchesTags;
          });
          return { ...sys, items: filteredItems };
        }).filter(s => s.items.length > 0);
        return { ...cluster, systems: filteredSystems };
      }).filter(c => c.systems.length > 0);
    }, [hierarchy, search, filterTags]);

    // summary stats
    const totals = useMemo(() => {
      let all = 0, done = 0;
      rows.forEach(r => {
        const id = makeId(r.cluster, r.system, r.name);
        all++;
        if (checkedMap[id]) done++;
      });
      return { done, all, pct: all ? Math.round(100 * done / all) : 0 };
    }, [rows, checkedMap]);

    // export current data & progress as JSON file
    function exportJSON() {
      const payload = { rows, checkedMap, exportedAt: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'me_tracker_export.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    // load sample
    function loadSample() {
      setRows(SAMPLE);
      setCheckedMap({});
    }

    return (
      <div className="space-y-6">
        <header className="flex items-start justify-between gap-4">
          <div>
            <h1 className="text-3xl font-bold text-accent">Mass Effect Exploration Tracker</h1>
            <p className="text-sm text-muted mt-1">Dark themed, single-file app. Import CSV from your spreadsheet, save progress locally, search, filter, and export.</p>
            <div className="mt-3 flex items-center gap-3">
              <div className="bg-mepanel rounded px-3 py-2 text-xs flex items-center gap-2">
                <strong className="text-accent2">Total:</strong>
                <span>{totals.done} / {totals.all}</span>
                <div className="w-48 h-2 bg-gray-700 rounded overflow-hidden ml-2">
                  <div style={{width: `${totals.pct}%`}} className="h-full bg-gradient-to-r from-accent to-accent2"></div>
                </div>
                <span className="ml-2 text-sm text-muted">{totals.pct}%</span>
              </div>
            </div>
          </div>

          <div className="flex-shrink-0 space-y-2 text-right">
            <div className="flex items-center gap-2">
              <label className="bg-mepanel px-3 py-2 rounded text-sm cursor-pointer">
                <input type="file" accept=".csv" onChange={handleFile} className="hidden" />
                Import CSV
              </label>
              <button onClick={() => {
                const txt = prompt("Paste CSV content here (header row accepted). Example headers: cluster,system,name,tags");
                if (txt) importCSVText(txt);
              }} className="bg-mepanel px-3 py-2 rounded text-sm">Paste CSV</button>

              <button onClick={exportJSON} className="bg-gradient-to-r from-accent to-accent2 text-slate-900 px-3 py-2 rounded text-sm">Export JSON</button>
            </div>

            <div className="space-x-2">
              <button onClick={loadSample} className="px-3 py-1 rounded bg-mepanel text-sm">Load Sample</button>
              <button onClick={clearProgress} className="px-3 py-1 rounded bg-mepanel text-sm">Clear Progress</button>
              <button onClick={clearAllData} className="px-3 py-1 rounded bg-red-600 text-sm">Clear All Data</button>
            </div>
          </div>
        </header>

        <section className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div className="md:col-span-2 space-y-4">
            <div className="flex items-center gap-3">
              <input
                value={search}
                onChange={e => setSearch(e.target.value)}
                placeholder="Search cluster / system / name..."
                className="flex-1 bg-mepanel px-3 py-2 rounded text-sm placeholder:text-muted"
              />
              <input
                value={filterTags}
                onChange={e => setFilterTags(e.target.value)}
                placeholder="Filter tags (comma-separated, e.g. Asari Writing)"
                className="min-w-[220px] bg-mepanel px-3 py-2 rounded text-sm placeholder:text-muted"
              />
            </div>

            <div className="space-y-3">
              {visibleHierarchy.length === 0 ? (
                <div className="p-6 bg-mepanel rounded text-center text-muted">No results. Import your CSV or adjust the search/filter.</div>
              ) : visibleHierarchy.map(cluster => {
                // cluster progress computed from all items in cluster
                const clusterItems = cluster.systems.flatMap(s => s.items);
                const cp = countCompleted(clusterItems, checkedMap);
                const clusterCollapsed = collapsedClusters[cluster.name];
                return (
                  <div key={cluster.name} className="bg-gradient-to-r from-[#071a20] to-[#071127] p-4 rounded border border-[#132029]">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        <button
                          onClick={() => setCollapsedClusters(prev => ({...prev, [cluster.name]: !prev[cluster.name]}))}
                          className="text-accent px-2 py-1 rounded"
                        >
                          {clusterCollapsed ? '▸' : '▾'}
                        </button>
                        <div>
                          <div className="text-lg font-semibold">{cluster.name}</div>
                          <div className="text-xs text-muted">{cp.done} / {cp.total} — {cp.pct}%</div>
                        </div>
                      </div>

                      <div className="flex items-center gap-3">
                        <div className="w-48 h-2 bg-gray-700 rounded overflow-hidden">
                          <div style={{width: `${cp.pct}%`}} className="h-full bg-gradient-to-r from-accent to-accent2"></div>
                        </div>
                        <button onClick={() => {
                          // mark all items in cluster as checked/un-checked (toggle to all-checked if not all)
                          const allChecked = clusterItems.every(it => checkedMap[it.id]);
                          setCheckedMap(prev => {
                            const next = { ...prev };
                            clusterItems.forEach(it => next[it.id] = !allChecked);
                            return next;
                          });
                        }}
                        className="bg-mepanel px-2 py-1 rounded text-sm">Toggle All</button>
                      </div>
                    </div>

                    {!clusterCollapsed && (
                      <div className="mt-3 space-y-2">
                        {cluster.systems.map(sys => {
                          const sysItems = sys.items;
                          const sp = countCompleted(sysItems, checkedMap);
                          const sysCollapsed = collapsedSystems[cluster.name + '||' + sys.name];
                          return (
                            <div key={sys.name} className="bg-[rgba(255,255,255,0.02)] p-3 rounded">
                              <div className="flex items-center justify-between">
                                <div className="flex items-center gap-2">
                                  <button
                                    onClick={() => setCollapsedSystems(prev => ({...prev, [cluster.name + '||' + sys.name]: !prev[cluster.name + '||' + sys.name]}))}
                                    className="text-sm px-2 py-1 text-accent rounded"
                                  >
                                    {sysCollapsed ? '▸' : '▾'}
                                  </button>
                                  <div>
                                    <div className="font-medium">{sys.name}</div>
                                    <div className="text-xs text-muted">{sp.done} / {sp.total} — {sp.pct}%</div>
                                  </div>
                                </div>
                                <div className="flex items-center gap-3">
                                  <div className="w-40 h-2 bg-gray-700 rounded overflow-hidden">
                                    <div style={{width: `${sp.pct}%`}} className="h-full bg-gradient-to-r from-accent to-accent2"></div>
                                  </div>
                                  <button onClick={() => {
                                    // toggle all in system
                                    const allChecked = sysItems.every(it => checkedMap[it.id]);
                                    setCheckedMap(prev => {
                                      const next = { ...prev };
                                      sysItems.forEach(it => next[it.id] = !allChecked);
                                      return next;
                                    });
                                  }} className="bg-mepanel px-2 py-1 rounded text-sm">Toggle</button>
                                </div>
                              </div>

                              {!sysCollapsed && (
                                <div className="mt-3 grid grid-cols-1 md:grid-cols-2 gap-2">
                                  {sys.items.map(it => (
                                    <label key={it.id} className="flex items-center gap-2 bg-transparent px-2 py-1 rounded hover:bg-[rgba(255,255,255,0.02)]">
                                      <input
                                        type="checkbox"
                                        checked={!!checkedMap[it.id]}
                                        onChange={() => toggleItem(it.id)}
                                        className="w-4 h-4 rounded text-accent focus:ring-0"
                                      />
                                      <div className="flex-1 text-sm">
                                        <div className="flex items-center gap-2">
                                          <div className="truncate">{it.name}</div>
                                          {it.tags.length > 0 && <div className="text-xs text-muted ml-2">[{it.tags.join(', ')}]</div>}
                                        </div>
                                        <div className="text-xs text-muted">{it.id}</div>
                                      </div>
                                    </label>
                                  ))}
                                </div>
                              )}
                            </div>
                          );
                        })}
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>

          <aside className="space-y-4">
            <div className="bg-mepanel p-4 rounded">
              <h3 className="text-accent font-semibold">Quick Filters</h3>
              <div className="mt-3 space-y-2">
                <div>
                  <div className="text-xs text-muted">Tags (click to add filter)</div>
                  <div className="mt-2 flex flex-wrap gap-2">
                    {allTags.length === 0 ? <div className="text-sm text-muted">No tags detected</div> :
                      allTags.map(t => (
                        <button
                          key={t}
                          onClick={() => {
                            const cur = filterTags.split(',').map(x=>x.trim()).filter(Boolean);
                            if (cur.includes(t.toLowerCase())) return;
                            setFilterTags(cur.concat([t]).join(', '));
                          }}
                          className="px-2 py-1 rounded bg-[#07202a] text-sm text-accent"
                        >{t}</button>
                      ))
                    }
                  </div>
                </div>

                <div className="pt-2">
                  <div className="text-xs text-muted">Actions</div>
                  <div className="mt-2 flex flex-col gap-2">
                    <button onClick={() => {
                      // expand all
                      const next = {};
                      hierarchy.forEach(c => next[c.name] = false);
                      setCollapsedClusters(next);
                      setCollapsedSystems({});
                    }} className="px-2 py-1 bg-mepanel rounded text-sm">Expand All</button>

                    <button onClick={() => {
                      const next = {};
                      hierarchy.forEach(c => next[c.name] = true);
                      setCollapsedClusters(next);
                      setCollapsedSystems(prev => {
                        const nextSys = {};
                        hierarchy.forEach(c => c.systems.forEach(s => nextSys[c.name + '||' + s.name] = true));
                        return nextSys;
                      });
                    }} className="px-2 py-1 bg-mepanel rounded text-sm">Collapse All</button>

                    <button onClick={() => {
                      // select only unchecked items
                      const next = {...checkedMap};
                      rows.forEach(r => {
                        const id = makeId(r.cluster, r.system, r.name);
                        if (!next[id]) next[id] = false;
                      });
                      setCheckedMap(next);
                    }} className="px-2 py-1 bg-mepanel rounded text-sm">Normalize Progress</button>

                  </div>
                </div>
              </div>
            </div>

            <div className="bg-mepanel p-4 rounded">
              <h3 className="text-accent font-semibold">Import / Export Tips</h3>
              <ol className="list-decimal list-inside text-sm mt-2 text-muted space-y-1">
                <li>In Excel or Google Sheets: make columns <strong>cluster, system, name, tags</strong>.</li>
                <li>Export as <em>CSV</em> and use <strong>Import CSV</strong> or <strong>Paste CSV</strong>.</li>
                <li>Tags can be comma-separated, e.g. <code>Asari Writing,Land</code>.</li>
                <li>Use <strong>Export JSON</strong> to back up progress (includes checked boxes).</li>
              </ol>
            </div>

            <div className="bg-mepanel p-4 rounded text-sm text-muted">
              <div><strong>Tip:</strong> If you want, paste a CSV now with full entries and then use the Toggle All buttons to mark whole systems/clusters completed.</div>
            </div>
          </aside>
        </section>

        <footer className="text-xs text-muted text-center py-6">
          Single-file React app • Saves to browser localStorage • Designed for offline use
        </footer>
      </div>
    );
  }

  // Render
  ReactDOM.createRoot(document.getElementById('root')).render(<App />);

  </script>
</body>
</html>
